#!/bin/bash
# dbwebb: tool to manage course repos
#
# See more: http://dbwebb.se/dbwebb-cli
#
# Author: Mikael Roos, mos@dbwebb.se
#
# The MIT License (MIT)
#
# Copyright (c) 2014-2015 Mikael Roos (mos@dbwebb.se)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
#
# Current version
#
DBW_VERSION="v1.9.7 (2015-08-06)"
# --------------- DBWEBB FUNCTIONS PHASE START ---------------

#
# Does key exists in array?
#
function exists() {
    if [ "$2" != in ]; then
        echo "Incorrect usage."
        echo "Correct usage: exists {key} in {array}"
        return
    fi   
    eval '[ ${'$3'[$1]+muahaha} ]'
}



#
# Check if array contains a value
#
function contains() {
    local e
    for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
    return 1
}



#
# Join elements with separator
# join , a "b c" d #a,b c,d
# join / var local tmp #var/local/tmp
# join , "${FOO[@]}" #a,b,c
#
function join()
{ 
    local IFS="$1"; 
    shift; 
    echo "$*";
}



#
# Get the url to GitHub for a repo
#
function createGithubUrl(){
    echo "https://github.com/mosbth/$1$2"
}



#
# Check for installed commands
#
function checkCommand()
{
    local COMMAND="$1"

    if ! hash "$COMMAND" 2>/dev/null; then
        printf "Command $COMMAND not found."
    else 
        printf "$( which $COMMAND )"
    fi
}



#
# Execute a command in a controlled manner
#
#function wget {
#  if command wget -h &>/dev/null
#  then
#    command wget "$@"
#  else
#    set "${*: -1}"
#    lynx -source "$1" > "${1##*/}"
#  fi
#}



#
# Press enter to continue
#
pressEnterToContinue()
{
    printf "\nPress enter to continue..."
    read void
}



#
# Execute a command in a controlled manner
#
executeCommand()
{
    INTRO="$1"

    if [[ ! $SKIP_READLINE ]]
    then
        printf "$INTRO"
        pressEnterToContinue
    fi

    REALLY="$4"
    if [ ! -z $REALLY ]
    then
        printf "\nAre you really sure? [yN] "
        read answer
        default="n"
        answer=${answer:-$default}

        if [ ! \( "$answer" = "y" -o "$answer" = "Y" \) ]
        then
            printf "Exiting...\n"
            exit 0
        fi
    fi

    COMMAND="$2"

    if [[ $VERY_VERBOSE ]]
    then
        printf "\nExecuting command:"
        printf "\n$COMMAND"
        printf "\n-----------------------------------------"
        printf "\n"
    fi

    bash -c "$COMMAND"
    STATUS=$?

    if [[ $VERY_VERBOSE ]]
    then
        printf "\n-----------------------------------------"
        printf "\n"
    fi

    MESSAGE=$3
    if [ $STATUS = 0 ]
    then
        printf "$MSG_DONE $MESSAGE"
    else
        printf "$MSG_FAILED $MESSAGE"
    fi
    printf "\n"

    return $STATUS
}



#
# Check if within a valid course repo or exit
#
function checkIfValidCourseRepoOrExit()
{
    if [ "$DBW_COURSE_REPO_VALID" != "yes" ]; then
        printf "$MSG_FAILED Could not find file '$DBW_COURSE_FILE_NAME', this is not a valid course repo."
        printf "\nThis command must be executed within a valid course repo."
        printf "\n"
        exit 1
    fi
}



#
# Check if config file or exit
#
function checkIfValidConfigOrExit()
{
    if [ ! -f "$DBW_CONFIG_FILE" ]; then
        printf "$MSG_FAILED Could not find the configuration file '$DBW_CONFIG_FILE', this is needed for this operation."
        printf "\n"
        exit 1
    fi
}



#
# Set proper rights for files and directories
#
setChmod()
{
    if [[ $VERY_VERBOSE ]]; then
        printf "Ensuring that all files and directories are readable for all, below $DBW_COURSE_DIR.\n"
    fi

    find "$DBW_COURSE_DIR" -type d -exec chmod u+rwx,go+rx {} \;  
    find "$DBW_COURSE_DIR" -type f -exec chmod u+rw,go+r {} \;   
}



#
# Convert course specific module to path on disk
#
mapCmdToDir()
{
    local CMD="$1"
    local RES=""

    if [ -z "$CMD" ]; then 
        return
    fi 

    case "$CMD" in
        example)    RES="example" ;;
        tutorial)   RES="tutorial" ;;
        me)         RES="me" ;;
        redovisa)   RES="me/redovisa" ;;
        kmom01)     RES="me/kmom01" ;;
        kmom02)     RES="me/kmom02" ;;
        kmom03)     RES="me/kmom03" ;;
        kmom04)     RES="me/kmom04" ;;
        kmom05)     RES="me/kmom05" ;;
        kmom06)     RES="me/kmom06" ;;
        kmom10)     RES="me/kmom10" ;;
    esac

    if [ ! -z $RES ]; then 
        printf "$RES"
        return
    fi 

    case "$DBW_COURSE" in
        htmlphp)
            case "$CMD" in
                me1)        RES="me/kmom01/me1" ;;
                me2)        RES="me/kmom02/me2" ;;
                me3)        RES="me/kmom03/me3" ;;
                me4)        RES="me/kmom04/me4" ;;
                me5)        RES="me/kmom05/me5" ;;
                
                multi)      RES="me/kmom03/multi" ;;
                stylechooser) RES="me/kmom04/stylechooser" ;;
                jetty)      RES="me/kmom05/jetty" ;;
                
                lab1)       RES="me/kmom02/lab1" ;;
                lab2)       RES="me/kmom03/lab2" ;;
                lab3)       RES="me/kmom04/lab3" ;;
                lab4)       RES="me/kmom05/lab4" ;;
                lab5)       RES="me/kmom06/lab5" ;;
            esac
            ;;

        python)
            case "$CMD" in
                hello)      RES="me/kmom01/hello" ;;
                plane)      RES="me/kmom01/plane" ;;

                lab1)       RES="me/kmom02/lab1" ;;
                lab2)       RES="me/kmom03/lab2" ;;
                lab3)       RES="me/kmom04/lab3" ;;
                lab4)       RES="me/kmom05/lab4" ;;
                lab5)       RES="me/kmom06/lab5" ;;
                lab6)       RES="me/kmom06/lab6" ;;

                marvin1)    RES="me/kmom02/marvin1" ;;
                marvin2)    RES="me/kmom03/marvin2" ;;
                marvin3)    RES="me/kmom04/marvin3" ;;
                marvin4)    RES="me/kmom05/marvin4" ;;
                marvin5)    RES="me/kmom06/marvin5" ;;

                game1)      RES="me/kmom04/game1" ;;
                game2)      RES="me/kmom05/game2" ;;
                game3)      RES="me/kmom06/game3" ;;

                adventure)  RES="me/kmom10/adventure" ;;
            esac
            ;;

        javascript1)
            case "$CMD" in
                sandbox)      RES="me/kmom01/sandbox" ;;
                hangman)      RES="me/kmom06/hangman" ;;
                intelligence) RES="me/kmom10/intelligence" ;;

                lab1)       RES="me/kmom02/lab1" ;;
                lab2)       RES="me/kmom03/lab2" ;;
                lab3)       RES="me/kmom04/lab3" ;;
                lab4)       RES="me/kmom04/lab4" ;;
                lab5)       RES="me/kmom05/lab5" ;;

                flag1)      RES="me/kmom02/flag1" ;;
                flag2)      RES="me/kmom03/flag2" ;;
                flag3)      RES="me/kmom04/flag3" ;;
                flag4)      RES="me/kmom05/flag4" ;;
                flag5)      RES="me/kmom06/flag5" ;;

                baddie1)    RES="me/kmom02/baddie1" ;;
                baddie2)    RES="me/kmom03/baddie2" ;;
                baddie3)    RES="me/kmom04/baddie3" ;;
                #baddie4)    RES="me/kmom05/baddie4" ;;
                #baddie5)    RES="me/kmom06/baddie5" ;;
            esac
            ;;

        linux)
            case "$CMD" in
                install)    RES="me/kmom01/install" ;;
                vhosts)     RES="me/kmom02/vhosts" ;;
                mysite)     RES="me/kmom02/mysite" ;;
                irc)        RES="me/kmom03/irc" ;;
                script)     RES="me/kmom03/script" ;;
            esac
            ;;

        webapp)
            case "$CMD" in
                lab1)       RES="me/kmom02/lab1" ;;
                lab2)       RES="me/kmom03/lab2" ;;
                lab3)       RES="me/kmom04/lab3" ;;
                lab4)       RES="me/kmom05/lab4" ;;
                lab5)       RES="me/kmom06/lab5" ;;
            esac
            ;;

        webgl)
            case "$CMD" in
                #lab1)       RES="me/kmom02/lab1" ;;
                #lab2)       RES="me/kmom03/lab2" ;;
                #lab3)       RES="me/kmom04/lab3" ;;
                #lab4)       RES="me/kmom05/lab4" ;;
                #lab5)       RES="me/kmom06/lab5" ;;
                *)          NO_RES="Not implemented"
            esac
            ;;
    esac

    echo "$RES"
    return
}



#
# Get path to dir to check, use both parts of courses and fallback
# to absolute and relative paths.
#
function getPathToDirectoryFor()
{
    local dir="$( mapCmdToDir $1 )" 
    
    if [ -z "$command" ]; then
        echo "$DBW_CURRENT_DIR"
    elif [ -z "$dir" -a -d "$command" ]; then
        echo "$command"
    elif [ -z "$dir" -a -d "$DBW_CURRENT_DIR/$command" ]; then
        echo "$DBW_CURRENT_DIR/$command"
    elif [ -d "$DBW_COURSE_DIR" -a -d "$DBW_COURSE_DIR/$dir" ]; then
        echo "$DBW_COURSE_DIR/$dir"
    else 
        printf "\n$MSG_FAILED The item '$command' was mapped to directory '$dir' which is not a valid directory."
        printf "\n"
        exit 1
    fi
}



#
# Validate the uploaded files
#
createUploadDownloadPaths()
{
    SUBDIR="$( mapCmdToDir $ITEM )"

    if [ -z "$WHAT" -o -z "$WHERE" ]; then
        printf "$MSG_FAILED Missing argument for source or destination. Perhaps re-create the config-file?"
        printf "\n\n"
        exit 1
    fi

    if [ -d "$DBW_CURRENT_DIR/$ITEM" ]; then
        SUBDIR="${ITEM%/}"
    elif [ ! -z "$ITEM" -a -z "$SUBDIR" ]; then
        printf "\n$MSG_FAILED Not a valid combination course: '$DBW_COURSE' and item: '$ITEM'."
        printf "\n\n"
        exit 1
    fi

    if [ ! -z "$SUBDIR" ]; then
        WHAT="$WHAT/$SUBDIR/"
        WHERE="$WHERE/$SUBDIR/"
    else
        WHAT="$WHAT/"
        WHERE="$WHERE/"
    fi

    if [ ! -d "$WHAT" ]; then
        printf "\n$MSG_FAILED Target directory is not a valid directory: '$WHAT'"
        printf "\n\n"
        exit 1
    fi
}



#
# Selfupdate
#
selfupdate()
{
    local what="$1"
    local target="$DBW_EXECUTABLE_PATH"
    local remote=
    local silent="--quiet"
    local repo="https://raw.githubusercontent.com/mosbth/dbwebb-cli"
    
    if [[ $VERY_VERBOSE ]]; then
        silent=""
    fi
    
    case $what in
        dbwebb)
            remote="$repo/master/dbwebb2"
        ;;
        
        dbwebb-validate)
            remote="$repo/master/dbwebb2-validate"
        ;;
        
        dbwebb-inspect)
            remote="$repo/master/dbwebb2-inspect"
        ;;
    esac
    
    printf "Your current version is: "
    $what --version

    local intro="Selfupdating '$what' from $repo"
    local cmd="printf 'Downloading...'; wget $silent $remote -O /tmp/$$; printf ' installing...'; install /tmp/$$ $target; printf ' cleaning up...'; rm /tmp/$$; printf ' done.\n'"
    local message="to update '$what'."
    executeCommand "$intro" "$cmd" "$message"
        
    printf "The updated version is now: "
    $what --version
}



#
# Perform an assert
#
function assert()
{
    EXPECTED=$1
    TEST=$2
    MESSAGE=$3
    ASSERTS=$(( $ASSERTS + 1 ))
    local onlyExitStatus=$4
    local error=
    local status=

    bash -c "$TEST" &> "$TMPFILE"
    status=$?
    
    if [ \( -z "$onlyExitStatus" \) -o \( ! $status -eq $EXPECTED \) ]; then
        error=$( cat "$TMPFILE" )
    fi
    rm -f "$TMPFILE"

    if [ \( ! $status -eq $EXPECTED \) -o \( ! -z "$error" \) ]; then
        FAULTS=$(( $FAULTS + 1 ))

        printf "\n\n$MSG_WARNING $MESSAGE\n" 
        [ -z "$error" ] || printf "$error\n\n"
    fi

    return $status
}



#
# Perform an assert on exit value returned
# TODO Check if this is really needed by python inspect
#
assertExit()
{
    EXPECTED=$1
    TEST=$2
    MESSAGE=$3
    ASSERTS=$(( $ASSERTS + 1 ))

    bash -c "$TEST" &> "$TMPFILE"
    STATUS=$?
    ERROR=$( cat "$TMPFILE" )
    rm -f "$TMPFILE"

    if [ $STATUS -ne $EXPECTED ]; then
        FAULTS=$(( $FAULTS + 1 ))

        printf "\n$TEST"
        printf "\n\n$MSG_FAILED $MESSAGE\n" 
        [ -z "$ERROR" ] || printf "$ERROR\n\n"

        return 1
    fi

    return 0
}




#
# Clean up and output results from asserts
#
function assertResults()
{
    if [ $FAULTS -gt 0 ]
        then
        printf "\n\n$MSG_FAILED"
        printf " Asserts: $ASSERTS Faults: $FAULTS\n\n"
        exit 1
    fi
    
    printf "\n$MSG_OK"
    printf " Asserts: $ASSERTS Faults: $FAULTS\n"
    exit 0
}



# --------------- DBWEBB FUNCTIONS PHASE END ---------------
# --------------- DBWEBB BOOTSTRAP PHASE START ---------------

# Messages
MSG_OK="\033[0;30;42mOK\033[0m"
MSG_DONE="\033[1;37;40mDONE\033[0m"
MSG_WARNING="\033[43mWARNING\033[0m"
MSG_FAILED="\033[0;37;41mFAILED\033[0m"

# For asserts
ASSERTS=0
FAULTS=0
TMPFILE="/tmp/dbwebb-error-{$USER}-$$"



#
# Find my environment, before any work can be done
#


# What was the command issued?
DBW_EXECUTABLE_PATH="$0"
DBW_EXECUTABLE="$( basename "$0" )"

# Where is the executable
DBW_EXECUTABLE_DIR="$( dirname "$0" )"

# What is the current directory
DBW_CURRENT_DIR="$( pwd )"



# What is the directory of the current course repo, find recursivly up the tree
DBW_COURSE_FILE_NAME=".dbwebb.course"

dir="$DBW_CURRENT_DIR/."
while [ "$dir" != "/" ]; do 
    dir=$( dirname "$dir" )
    found="$( find "$dir" -maxdepth 1 -name $DBW_COURSE_FILE_NAME )"
    if [ "$found" ]; then 
        DBW_COURSE_DIR="$( dirname "$found" )"
        break
    fi
done



#
# Get the name of the course as $DBW_COURSE
#
function sourceCourseRepoFile()
{
    DBW_COURSE_FILE="$DBW_COURSE_DIR/$DBW_COURSE_FILE_NAME"
    DBW_COURSE_REPO_VALID=""
    if [ -f "$DBW_COURSE_FILE" ]; then
        DBW_COURSE_REPO_VALID="yes"
        source "$DBW_COURSE_FILE"
    fi    
}

# Get the name of the course as $DBW_COURSE
sourceCourseRepoFile



# Where is the .dbwebb.config-file
DBW_CONFIG_FILE_NAME=".dbwebb.config"

# Check if run as sudo, use SUDO_USER as HOME (only for selfupdate)
if [[ $SUDO_USER ]]; then
    DBW_CONFIG_FILE=$( eval echo "~$SUDO_USER/$DBW_CONFIG_FILE_NAME" )
else    
    DBW_CONFIG_FILE="$HOME/$DBW_CONFIG_FILE_NAME"
fi

if [ -f "$DBW_CONFIG_FILE" ]; then
    source "$DBW_CONFIG_FILE"
fi



# Detect if ssh-key is available
DBW_SSH_KEY_OPTION=""
if [ -f "$DBW_SSH_KEY" ]
then
    DBW_SSH_KEY_OPTION="-i '$DBW_SSH_KEY'"
fi



# Check OS
DBW_OS="$( uname -a )"

# Create the ssh-command with details from the config-file
SSH_CMD="ssh ${DBW_USER}@${DBW_HOST} $DBW_SSH_KEY_OPTION"

# Create the basis for the upload command
RSYNC_CMD="rsync -av --delete --exclude .git --exclude .gitignore --exclude literature --exclude tutorial --exclude .default -e \"ssh $DBW_SSH_KEY_OPTION\""
RSYNC_DOWNLOAD_CMD="rsync -avu -e \"ssh $DBW_SSH_KEY_OPTION\""

DBW_REMOTE_DESTINATION="${DBW_USER}@${DBW_HOST}:$DBW_REMOTE_BASEDIR/$DBW_COURSE"
DBW_REMOTE_WWW_DESTINATION="${DBW_USER}@${DBW_HOST}:$DBW_REMOTE_WWWDIR/$DBW_COURSE"

DBW_WWW="http://dbwebb.se/"
DBW_VALIDATE_CONFIGFILE="/home/saxon/students/dbwebb/dbwebb-general-config"
#DBW_INSPECT_CONFIGFILE="/home/saxon/students/dbwebb/dbwebb-general-config"
DBW_ARCHIVE="/home/saxon/students/dbwebb/archive/"


# Ass arrays not supporter on mac bash v3.
#declare -A DBW_REPOS
#DBW_REPOS[python]="https://github.com/mosbth/python"
#DBW_REPOS[javascript1]="https://github.com/mosbth/javascript1"
#DBW_REPOS[linux]="https://github.com/mosbth/linux"
#DBW_REPOS[webapp]="https://github.com/mosbth/webapp"
#DBW_REPOS[htmlphp]="https://github.com/mosbth/htmlphp"
DBW_COURSE_REPOS=( 'python' 'javascript1' 'linux' 'webapp' 'htmlphp' 'webgl' )
DBW_REPO="dbwebb-cli"


# --------------- DBWEBB BOOTSTRAP PHASE END ---------------
function usage ()
{
    local txt=(
"Utility dbwebb for working with course repos: http://dbwebb.se/dbwebb-cli"
"Usage: dbwebb [options] <command> [arguments]"
""
"Command:"
"  check             Check the environment."
"  config            (Re-)Create config file."
"  selfupdate        Update to latest version."
"  sshkey            Create and install ssh-keys."
"  login             Login to the remote server."
"  clone [repo]      Clone a course repo."
"  init              Init course repo and remote server."
"  github [repo]     Get urls to repo on GitHub."
"  update            Update course repo."
"  upload [part]     Upload to server."
"  download [part]   Download from server."
"  create labid      Create a lab."
"  validate [part]   Validate it."
"  publish [part]    Publish it."
"  inspect [course] [kmom] [user]  Inspect a kmom."
""
"Options:"
"  --inspect, -i  Help for inspect."
"  --verbose, -v  More verbose."
"  --yes, -y      Do not wait for my input."
"  --help, -h     Print help."
"  --version      Print version."
    )
    printf "%s\n" "${txt[@]}"
}



function badUsage ()
{
    local message="$1"
    local txt=(
"For an overview of the command, execute:"
"dbwebb --help"
    )
    
    if [[ "$message" ]]; then
        printf "$message\n"
    fi
    
    printf "%s\n" "${txt[@]}"
}



function usageGithub ()
{
    local txt=(
"Available course repos are: $( join , "${DBW_COURSE_REPOS[@]}" )"
"Usage: dbwebb github [course repo]"
""
"The repo 'dbwebb-cli' exists on GitHub."
"Repo:   $( createGithubUrl "$DBW_REPO" )"
"Issues: $( createGithubUrl "$DBW_REPO" "/issues" )"
)
    printf "%s\n" "${txt[@]}"
}



function badUsageGithub ()
{
    local message="$1"

    if [[ "$message" ]]; then
        printf "$message\n"
    fi
    
    usageGithub
}


function usageClone ()
{
    local txt=(
"Available course repos are: $( join , "${DBW_COURSE_REPOS[@]}" )"
"Usage: dbwebb clone [course repo]"
"Read more: http://dbwebb.se/dbwebb-cli/clone"
)
    printf "%s\n" "${txt[@]}"
}



function badUsageClone ()
{
    local message="$1"

    if [[ "$message" ]]; then
        printf "$message\n"
    fi
    
    usageClone
}



function usageInspect ()
{
    local txt=(
"dbwebb inspect:"
"Use to inspect a kmom, as the teachers does, self inspect your own kmom before handing it in."
""
"Usage: dbwebb inspect <kmom>"
"Use to self inspect a kmom in current course repo. This will also upload all your files to the remote server to ensure you are checking the latest code."
""
"Usage: dbwebb inspect <course> <kmom>"
"Use to inspect a kmom in any course repo that is uploaded to the remote server. No need of being in a valid course repo. No upload of files."
""
"Usage: dbwebb inspect <course> <kmom> <user>"
"Use to inspect a kmom in any course for any user, without the need of being in a valid course repo. No upload of files."
)
    printf "%s\n" "${txt[@]}"
}



function version ()
{
    local txt=(
"dbwebb version $DBW_VERSION"
    )
    printf "%s\n" "${txt[@]}"
}



function inspectUsage ()
{
    local txt=(
"Using dbwebb inspect, for another student than youreself,"
"needs extra privilegies."
""
"Add acronym for inspect"
" sudo /usr/local/sbin/setpre-dbwebb-kurser.bash acronym"
""
"Add or delete teacher (on each server)"
" sudo update-dbwebb-kurser.bash -a acronym"
" sudo update-dbwebb-kurser.bash -d acronym"
""
"Execute command as the user dbwebb."
" sudo -u dbwebb script"
    )
    printf "%s\n" "${txt[@]}"
}
#------------------------- HERE ARE THE MAIN COMMANDS -----------------------


#
# Create the config file .dbwebb.config.
#
function createConfig()
{
    local first=$1
    local noInput=$2
    local acronym
    local remoteHost

    if [ -z $first ]
    then

        printf "The config-file '$DBW_CONFIG_FILE_NAME' will now be created in your home directory: '$HOME'"

    elif [ $first = "update" ]
    then

        printf "Your config file will be automatically updated. Then re-run your command.\n"

    elif [ $first = "upgrade" ]
    then

        printf "Your config file will be automatically updated."

    elif [ $first = "create" ]
    then

        printf "I will now re-create the configuration file '$DBW_CONFIG_FILE_NAME' in your home directory: '$HOME'."

    fi


    if [[ ! $noInput ]]; then
        DBW_USER=${DBW_USER:-$USER}
        printf "\nWhat is your student acronym? [$DBW_USER] "
        read acronym
    fi

    acronym=${acronym:-$DBW_USER}
    remoteHost=${remoteHost:-ssh.student.bth.se}
    sshKey=${sshKey:-\$HOME/.ssh/dbwebb}
    remoteDir=${remoteDir:-dbwebb-kurser}
    remoteWwwHost=${remoteWwwHost:-http://www.student.bth.se/}
    remoteWww=${remoteWww:-www/dbwebb-kurser}
    baseurl=${baseurl:-http://www.student.bth.se/~$acronym/$remoteDir}
    laburl=${laburl:-http://www.student.bth.se/~mosstud/kod-exempel/lab}

    echo "DBW_USER='$acronym'"               > "$DBW_CONFIG_FILE"
    echo "DBW_HOST='$remoteHost'"           >> "$DBW_CONFIG_FILE"
    echo "DBW_WWW_HOST='$remoteWwwHost'"    >> "$DBW_CONFIG_FILE"
    echo "DBW_SSH_KEY=\"$sshKey\""          >> "$DBW_CONFIG_FILE"
    echo "DBW_REMOTE_BASEDIR='$remoteDir'"  >> "$DBW_CONFIG_FILE"
    echo "DBW_REMOTE_WWWDIR='$remoteWww'"   >> "$DBW_CONFIG_FILE"
    echo "DBW_BASEURL='$baseurl'"           >> "$DBW_CONFIG_FILE"
    echo "DBW_LABURL='$laburl'"             >> "$DBW_CONFIG_FILE"

    printf "$MSG_DONE The config file '$DBW_CONFIG_FILE' is now up-to-date.\n"
}



#
# Create default files.
#
function dbwebb-init-me()
{
    local meDefault="$DBW_COURSE_DIR/.default/"
    local me="$DBW_COURSE_DIR/me/"

    local intro="Creating and initiating the directory 'me/' by copying directory structure and files from the directory '.default/' (will not overwrite existing files)."
    local command="rsync -av --exclude README.md --ignore-existing \"$meDefault\" \"$me\""
    local message="to init the directory 'me/'."

    checkIfValidCourseRepoOrExit
    executeCommand "$intro" "$command" "$message"
}



#
# Init directory structure at the server.
#
function dbwebb-init-server()
{    
    local intro="Intiating the remote server '$DBW_HOST' by connecting as '$DBW_USER' and creating directories (if needed) where all uploaded files will reside."
    # TODO Should use DBW_BASEDIR 
    local command="$SSH_CMD 'sh -c \"if [ ! -d \"$DBW_REMOTE_BASEDIR\" ]; then mkdir \"$DBW_REMOTE_BASEDIR\"; fi; chmod 700 \"$DBW_REMOTE_BASEDIR\"; echo; echo \"$DBW_REMOTE_BASEDIR:\"; ls -lF \"$DBW_REMOTE_BASEDIR\"; if [ ! -d \"$DBW_REMOTE_WWWDIR\" ]; then mkdir \"$DBW_REMOTE_WWWDIR\"; fi; chmod 755 \"$DBW_REMOTE_WWWDIR\"; echo; echo \"$DBW_REMOTE_WWWDIR:\"; ls -lF \"$DBW_REMOTE_WWWDIR\"\"'"
    local message="to init the base dirs on the server."

    checkIfValidConfigOrExit
    executeCommand "$intro" "$command" "$message"
}



#
# Create default directory structure on the server for dbwebb-kurser/.
#
function dbwebb-init-structure-dbwebb-kurser()
{
    local intro="Ensuring that the directory structure exists on the server by syncing directory structure to dbwebb-kurser/ (will not overwrite existing files)."
    local command=
    local message="to init the directory structure on the server."

    checkIfValidConfigOrExit
    checkIfValidCourseRepoOrExit

    WHAT="$DBW_COURSE_DIR"
    WHERE="$DBW_REMOTE_DESTINATION"
    ITEM=""
    SUBDIR=""

    createUploadDownloadPaths

    command="rsync -av --exclude .git --exclude .gitignore --exclude literature --exclude tutorial --exclude .default --exclude example --include='*/' --include='.??*' --exclude='*' -e \"ssh $DBW_SSH_KEY_OPTION\" '$WHAT' '$WHERE'"
    executeCommand "$intro" "$command" "$message"
}



#
# Create default directory structure on the server for dbwebb-kurser/.
#
function dbwebb-init-structure-www-dbwebb-kurser()
{
    local intro="Ensuring that the directory structure exists on the server by syncing the me/ directory structure to www/dbwebb-kurser (will not overwrite existing files)."
    local command=
    local message="to init the www-directory structure on the server."

    checkIfValidConfigOrExit
    checkIfValidCourseRepoOrExit

    WHAT="$DBW_COURSE_DIR"
    WHERE="$DBW_REMOTE_WWW_DESTINATION"
    ITEM=""
    SUBDIR=""

    createUploadDownloadPaths

    command="rsync -av --exclude .git --exclude .gitignore --exclude literature --exclude tutorial --exclude .default --exclude example --include='*/' --exclude='*' -e \"ssh $DBW_SSH_KEY_OPTION\" '$WHAT' '$WHERE'"
    executeCommand "$intro" "$command" "$message"
}



#
# Init course repo and directory structure at the server.
#
function dbwebb-init()
{    
    dbwebb-init-me
    dbwebb-init-server
    dbwebb-init-structure-dbwebb-kurser
    dbwebb-init-structure-www-dbwebb-kurser
}



#
# Create and use ssh-keys to login.
#
function dbwebb-sshkey()
{
    local sshkey="$HOME/.ssh/dbwebb"

    if [ ! -d "$HOME/.ssh" ]
    then
        mkdir "$HOME/.ssh"
    fi

    printf "First we need to create a ssh key and store it locally."
    printf "\nPress enter/return to continue..."
    read void
    ssh-keygen -t dsa -f "$sshkey" -N ''
    
    # Bug (?) om Cygwin & win 8
    # TODO refactor 
    #if [ $IS_CYGWIN = "yes" ]; then
    #    chgrp -vR "$CYGWIN_DEFAULT_GROUP" "$HOME/.ssh"
    #fi

    chmod 700 "$HOME/.ssh"
    chmod 600 "$sshkey" "$sshkey.pub"

    intro="I will now install the ssh-key at the remote server."
    command="cat '$sshkey.pub' | ssh $DBW_USER@$DBW_HOST 'sh -c \"if [ ! -d .ssh ]; then mkdir .ssh; fi; chmod 700 .ssh; touch .ssh/authorized_keys; cat >> .ssh/authorized_keys\"'"
    message="to install the ssh-keys."    
    executeCommand "$intro" "$command" "$message"
}



#
# Login to the server
#
function dbwebb-login()
{
    local intro="I will now login to the server '$DBW_HOST' as '$DBW_USER' using ssh-keys if available."
    local command="$SSH_CMD"
    local message="to establish the connection."
    
    checkIfValidConfigOrExit
    executeCommand "$intro" "$command" "$message"
}



#
# Update course repo to latest version
#
function dbwebb-update()
{
    local intro="Update course-repo with latest changes from its master at GitHub."
    local command="git pull"
    local message="to update course repo."
    
    checkIfValidCourseRepoOrExit
    executeCommand "$intro" "$command" "$message"
}



#
# Display information on the environment
#
function dbwebb-check()
{
    printf "Details on installed utilities."
    printf "\n------------------------------------"
    printf "\nbash:               %s" "$( checkCommand bash )"
    printf "\ngit:                %s" "$( checkCommand git )"
    printf "\nssh:                %s" "$( checkCommand ssh )"
    printf "\nrsync:              %s" "$( checkCommand rsync )"
    printf "\nwget:               %s" "$( checkCommand wget )"
    printf "\ncurl:               %s" "$( checkCommand curl )"
    printf "\n"

    printf "\nDetails on the dbwebb-environment."
    printf "\n------------------------------------"
    printf "\nOperatingsystem:    $DBW_OS"
    printf "\nCommand issued:     $DBW_EXECUTABLE"
    printf "\nVersion of dbwebb:  $DBW_VERSION"
    printf "\nPath to executable: '$DBW_EXECUTABLE_DIR'"
    printf "\nConfig-file:        '$DBW_CONFIG_FILE'"
    printf "\nWorking directory:  '$DBW_CURRENT_DIR'"
    printf "\nLocal user:         '$USER'"
    printf "\nLocal homedir:      '$HOME'"
    printf "\nRemote user:        '$DBW_USER'"
    printf "\nRemote host:        '$DBW_HOST'"
    printf "\n"

    echo
    echo "Details on current course-repo."
    echo "------------------------------------"

    if [ "$DBW_COURSE_REPO_VALID" = "yes" ]; then
        echo "Current course-repo:   '$DBW_COURSE'"
        echo "Course directory:      '$DBW_COURSE_DIR'"
        echo "Course-repo version:   $( git describe --always )"
        echo "Latest update to course repo was:"
        echo 
        git log -1
        echo
    else 
        echo "This is not a valid course repo."
        echo
    fi

    if contains python "$@"; then
        echo "Details on Python installed utilities."
        echo "------------------------------------"
        echo "python3:            $( checkCommand python3 )"
        echo "pip3:               $( checkCommand pip3 )"
        echo 
    fi
}



#
# Create or re-create the config file.
#
function dbwebb-config()
{
    createConfig
}



#
# Push/upload results to the server
#
function dbwebb-upload()
{
    WHAT="$DBW_COURSE_DIR"
    WHERE="$DBW_REMOTE_DESTINATION"
    ITEM="$1"
    SUBDIR=""

    checkIfValidConfigOrExit
    checkIfValidCourseRepoOrExit
    createUploadDownloadPaths
    setChmod

    local intro="Uploading the directory '$WHAT' to '$WHERE'."
    local command="$RSYNC_CMD '$WHAT' '$WHERE'"
    local message="to upload data."
    executeCommand "$intro" "$command" "$message"
}



#
# Pull/download from the server
#
function dbwebb-download()
{
    WHAT="$DBW_COURSE_DIR"
    WHERE="$DBW_REMOTE_DESTINATION"
    ITEM="$1"
    SUBDIR=""
    local who="$2"

    if [ $who != "$DBW_USER" ]; then
        WHERE="${DBW_USER}@${DBW_HOST}:~$who/$DBW_REMOTE_BASEDIR/$DBW_COURSE"
    fi
    
    echo $WHERE
    checkIfValidConfigOrExit
    checkIfValidCourseRepoOrExit
    createUploadDownloadPaths
    echo $WHERE

    local intro="Downloading the directory '$WHERE' to '$WHAT'.\nExisting local files that are newer will not be overwritten."
    local command="$RSYNC_DOWNLOAD_CMD '$WHERE' '$WHAT'"
    local message="to download data."
    executeCommand "$intro" "$command" "$message" "really?"
}


#
# Validate the uploaded files
#
function dbwebb-validate()
{
    checkIfValidConfigOrExit
    checkIfValidCourseRepoOrExit
    setChmod

    WHAT="$DBW_COURSE_DIR"
    WHERE="$DBW_REMOTE_DESTINATION"
    ITEM="$1"
    SUBDIR=""
    createUploadDownloadPaths

    local log="$HOME/.dbwebb-validate.log"
    local intro="Uploading the directory '$WHAT' to '$WHERE' for validation."
    local command1="$RSYNC_CMD '$WHAT' '$WHERE'"
    local command2="rsync -av --exclude .git --exclude .gitignore --exclude .default --include='.??*' --exclude='*' -e \"ssh $DBW_SSH_KEY_OPTION\" '$DBW_COURSE_DIR/' '$DBW_REMOTE_DESTINATION/'"
    local command3="$SSH_CMD 'dbwebb-validate --course-repo \"$DBW_REMOTE_BASEDIR/$DBW_COURSE\" \"$DBW_REMOTE_BASEDIR/$DBW_COURSE/$SUBDIR\"' 2>&1 | tee '$log';"
    local message="to validate course results.\nSaved a log of the output: less -R '$log'"
    executeCommand "$intro" "$command1; $command2; $command3" "$message"
}



#
# Publish the uploaded files
#
function dbwebb-publish()
{
    checkIfValidConfigOrExit
    checkIfValidCourseRepoOrExit
    setChmod

    WHAT="$DBW_COURSE_DIR"
    WHERE="$DBW_REMOTE_DESTINATION"
    ITEM="$1"
    SUBDIR=""
    createUploadDownloadPaths

    local log="$HOME/.dbwebb-publish.log"
    local intro="Uploading the directory '$WHAT' to '$WHERE' to validate and publish."
    local command1="$RSYNC_CMD '$WHAT' '$WHERE'"
    local command2="rsync -av --exclude .git --exclude .gitignore --exclude .default --include='.??*' --exclude='*' -e \"ssh $DBW_SSH_KEY_OPTION\" '$DBW_COURSE_DIR/' '$DBW_REMOTE_DESTINATION/'"
    local command3="$SSH_CMD 'dbwebb-validate --publish --course-repo \"$DBW_REMOTE_BASEDIR/$DBW_COURSE\" --publish-to \"$DBW_REMOTE_WWWDIR/$DBW_COURSE/$SUBDIR\" \"$DBW_REMOTE_BASEDIR/$DBW_COURSE/$SUBDIR\"' 2>&1 | tee '$log';"
    local message="to validate and publish course results.\nSaved a log of the output: less -R '$log'"
    executeCommand "$intro" "$command1; $command2; $command3" "$message"

    if [ $? -eq 0 ]; then
        printf "Your files are now"
    else
        printf "Some of your files might be"
    fi
    printf " published on:\n $DBW_BASEURL/$DBW_COURSE/$SUBDIR\n"
}



#
# Inspect uploaded files
#
function dbwebb-inspect()
{
    local course=
    local kmom=
    local who=
    local forWho=" for user '$DBW_USER'"
    local forCourse=
    local willUpload=
    local archive=

    checkIfValidConfigOrExit

    if [[ $3 ]]; then
        course="$1"
        forCourse=" in course '$course'"
        kmom="$2"
        who="$3"
        forWho=" for user '$who'"
        if [ "$who" != "$DBW_USER" ]; then
            archive="--archive $DBW_ARCHIVE"
        fi
    elif [[ $2 ]]; then
        course="$1"
        forCourse=" in course '$course'"
        kmom="$2"
    elif [[ $1 ]]; then
        course="$DBW_COURSE"
        kmom="$1"
        forCourse=" in course repo '$course'"
        willUpload="\nI will start by uploading the course repo to the remote server."
    else
        usageInspect
        exit 0
    fi    

    inspecUser=${who:=$DBW_USER}

    local intro="I will now inspect '$kmom'${forCourse}${forWho}.$willUpload"
    local log="$HOME/.dbwebb-inspect.log"
    local command1=
    local command2="$SSH_CMD \"dbwebb-inspect $archive --publish-url $DBW_BASEURL --publish-to ~$DBW_USER/$DBW_REMOTE_WWWDIR --base-url $DBW_WWW_HOST~$inspecUser/$DBW_REMOTE_BASEDIR ~$inspecUser/$DBW_REMOTE_BASEDIR/$course $kmom\" 2>&1 | tee '$log';"
    local message="to inspect the course results.\nSaved a log of the output, review it as:\nless -R '$log'"

    # Upload only if
    if [[ $willUpload ]]; then
        checkIfValidCourseRepoOrExit
        setChmod
        command1="$RSYNC_CMD '$DBW_COURSE_DIR/' '$DBW_REMOTE_DESTINATION/';"
    fi

    executeCommand "$intro" "$command1 $command2" "$message"
}



#
# Create a lab
#
dbwebb-create()
{
    local myWget=
    local lab="$1"
    local subdir="$( mapCmdToDir $lab )"
    local where="$DBW_COURSE_DIR/$subdir"
    
    if [ -z "$subdir" ]; then
        printf "$MSG_FAILED Not a valid combination of '$DBW_COURSE' and '$lab'.\n"
        exit 2
    fi

    checkIfValidConfigOrExit
    checkIfValidCourseRepoOrExit

    printf "Creating $DBW_COURSE $lab in '$where'.\n"

    # Check if init was run?
    if [ ! -d "$where" ]; then
        printf "$MSG_FAILED The directory '$where' is missing.\nDid you run the command 'dbwebb init'?\n"
        exit 2
    fi

    # Check if lab is already there
    if [ -f "$where/answer.php" -o -f "$where/answer.js" -o -f "$where/answer.py" ]; then
        printf "$MSG_FAILED You have already created lab-files at: '$where'\nRemove the files in the directory, then you can generate new files.\n"
        exit 2
    fi

    # Check for wget or curl
    if hash wget 2> /dev/null; then
        [[ $VERY_VERBOSE ]] && echo "Using wget as download method."
        myWget="wget -qO"
    elif hash curl 2> /dev/null; then
        [[ $VERY_VERBOSE ]] && echo "Using curl as download method."
        myWget="curl -so"
    else
        printf "$MSG_FAILED Missing wget and curl, can not create a lab without both.\n"
        exit 2
    fi

    # Create the key
    local getKey="action=only-key&acronym=$DBW_USER&course=$DBW_COURSE&doGenerate=Submit"
    local key="$( ${myWget}- "$DBW_LABURL/?$getKey&lab=$lab" )"

    # The lab description
    local getLab="lab.php?lab"
    printf " instruction.html"
    [[ $VERY_VERBOSE ]] && printf " ($DBW_LABURL/$getLab&key=$key)"
    $myWget "$where/instruction.html" "$DBW_LABURL/$getLab&key=$key"

    # The lab documents
    case "$DBW_COURSE" in
        
        htmlphp)
            printf "\n answer.php"
            $myWget "$where/answer.php" "$DBW_LABURL/lab.php?answer-php&key=$key"

            printf "\n CDbwebb.php"
            $myWget "$where/CDbwebb.php" "$DBW_LABURL/lab.php?answer-php-assert&key=$key"

            printf "\n answer.json"
            $myWget "$where/answer.json" "$DBW_LABURL/lab.php?answer-json&key=$key"
        ;;
        
        javascript1)
            printf "\n answer.html"
            $myWget "$where/answer.html" "$DBW_LABURL/lab.php?answer-html&key=$key"

            printf "\n answer.js"
            $myWget "$where/answer.js" "$DBW_LABURL/lab.php?answer-js&key=$key"
        ;;

        python)
            printf "\n answer.py"
            $myWget "$where/answer.py" "$DBW_LABURL/lab.php?answer-py&key=$key"
            chmod 755 "$where/answer.py"

            printf "\n Dbwebb.py"
            $myWget "$where/Dbwebb.py" "$DBW_LABURL/lab.php?answer-py-assert&key=$key"

            printf "\n answer.json"
            $myWget "$where/answer.json" "$DBW_LABURL/lab.php?answer-json&key=$key"
        ;;

    esac

    # Extras
    local getAnswerExtra="lab.php?answer-extra"
    printf "\n (extras)"
    $myWget "$where/extra.tar" "$DBW_LABURL/$getAnswerExtra&key=$key"
    tar -xvf "$where/extra.tar" -C "$where"
    rm -f "$where/extra.tar"

    printf "\n$MSG_DONE You can find the lab and all files here: '$where'\n"
}



#
# Selfupdate
#
dbwebb-selfupdate()
{
    selfupdate dbwebb
    dbwebb updateconfig
}



#
# Clone a repo
#
dbwebb-clone()
{
    local repo="$1"
    local saveas="$2"
    
    if [[ ! $repo ]]; then
        usageClone
        exit 0
    fi
    
    if ! contains "$repo" "${DBW_COURSE_REPOS[@]}"; then
        badUsageClone "$MSG_FAILED Not a valid course repo: '$repo'"
        exit 1
    fi
    
    local intro="Cloning course-repo for '$repo' from '$( createGithubUrl "$repo" )'."
    local cmd="git clone \"$( createGithubUrl "$repo" ).git\" $saveas"
    local message="to clone course repo."
    executeCommand "$intro" "$cmd" "$message"
}



#
# Link to a repo on GitHub
#
dbwebb-github()
{
    local repo="$1"
    
    if [[ ! $repo ]]; then
        usageGithub
        exit 0
    fi
    
    if ! contains "$repo" "${DBW_COURSE_REPOS[@]}"; then
        badUsageGithub "$MSG_FAILED Not a valid course repo: '$repo'"
        exit 1
    fi
    
    echo "The course repo '$repo' exists on GitHub:"
    echo "Repo:   $( createGithubUrl "$repo" )"
    echo "Issues: $( createGithubUrl "$repo" "/issues" )"
}



#
# Update config during selfupdate
#
dbwebb-updateconfig()
{
    createConfig "selfupdate" "no"
}



# --------------- DBWEBB MAIN START HERE ------------------------------
#
# Process options
#
while (( $# ))
do
    case "$1" in
        
        --inspect | -i)
            inspectUsage
            exit 0
        ;;

        --verbose | -v)
            VERY_VERBOSE="yes"
            shift
        ;;

        --yes | -y)
            SKIP_READLINE="yes"
            shift
        ;;

        --help | -h)
            usage
            exit 0
        ;;
        
        --version)
            version
            exit 0
        ;;
                
        #--course)
        #    DBW_COURSE=$2
        #    shift
        #    shift
        #;;
                
        update         \
        | check        \
        | clone        \
        | github       \
        | config       \
        | updateconfig \
        | selfupdate   \
        | sshkey       \
        | login        \
        | upload       \
        | download     \
        | validate     \
        | publish      \
        | inspect      \
        | create       \
        | init         \
        | init-server  \
        | init-structure-dbwebb-kurser \
        | init-structure-www-dbwebb-kurser \
        | init-me)
            command=$1
            shift
            dbwebb-$command $*
            exit 0
        ;;
        
        *)
            badUsage "$MSG_FAILED Option/command not recognized."
            exit 2
        ;;
        
    esac
done

badUsage
exit 1
